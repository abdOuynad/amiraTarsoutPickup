# -*- coding: utf-8 -*-
"""PFE Classe.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mK2QO_eQVnqsyXHOq4B4-nIjV53gzeUF
"""

import copy
import random
import time
import concurrent.futures
import pandas as pd
from geopy.distance import geodesic
import math

class pickup :
  #
  def __init__(self,P):
    self.D = None
    self.N = None
    self.P = P
    self.D_copy = None
    self.coordonne = None
    self.Clustering = None
    self.Center = None
    self.vehicule_matrix = []
    self.pop = []
    self.pop_ameliori = []
  #
  def produit(self,W):
    D = self.D_copy
    L = [0] * len(D)
    for j in range(len(D)):
        for i in range(len(D)):
            L[j] +=  W[i]*D[i][j]
    return L
  #
  def matrice_actualisée (self,s):
    D = self.D_copy
    for i in range(len(D)):
        for j in range(len(D)):
            D[i][j]=min (D[i][j],D[i][s])
    self.D_copy=D
    return self.D_copy
  #
  def un_médian(self,W):
    D = self.D_copy
    L=[]
    Y=(len(D))*[0]
    V=self.produit(W)
    y= V.index(min(V))
    Y[y]=1
    return y
  #
  def pmedian(self,W):
    P = self.P
    D = self.D_copy
    L=[0]*len(D)
    for i in range(P):
        s=self.un_médian(W)
        D=self.matrice_actualisée (s)
        L[s]=1
    return L
  #
  def Recouvrement(self):
    D = self.D
    P = self.P
    N = self.N
    W= [1] * len(D)
    self.D_copy = copy.deepcopy(D)
    L = self.pmedian(W)
    LN = [i for i in range(len(L)) if L[i] == 1]
    indx=[i for i in range(len(LN))]
    Cl_final = [[] for _ in range(len(LN))]
    for i in range(len(N)):
        client = N[i]
        min_distance = float('inf')
        nearest_center = -1
        nearest_center_index=-1
        for j in range(len(LN)):
            center = LN[j]
            distance = self.D[client][center]
            if distance < min_distance:
                min_distance = distance
                nearest_center = center
                nearest_center_index=indx[j]
        Cl_final[nearest_center_index].append(client)
    #
    self.Center = LN
    self.Clustering = Cl_final
    #
    return self.Clustering
  #
  def CW(self,D):
    S=[]
    I1=[]
    I2=[]

    d=list(D.values())[0]
    for i in range (1, len(d)):
        for j in range (i+1, len(list(d[0].values())[0])):
            S.append(list(d[0].values())[0][i]+list(d[0].values())[0][j]-list(d[i].values())[0][j])
            #S.append(D[0][i]+D[0][j]-a*D[i][j])
            I1.append(list(d[i].keys())[0])
            #I1.append(i)
            I2.append(list(d[j].keys())[0])
            #I2.append(j)
    for i in range (len (S)-1):
        for j in range (i+1, len (S)):
            if (S[i]<=S[j]):
                b=S[i]
                S[i]=S[j]
                S[j]=b
                c=I1[i]
                I1[i]=I1[j]
                I1[j]=c
                d=I2[i]
                I2[i]=I2[j]
                I2[j]=d
    I= [[0, 0] for i in range(len(S))]
    for i in range (len (S)):
            I[i][0]=I1[i]
            I[i][1]=I2[i]
    return I
  #
  def ajouter_element1(self,L, M):
    x=L[0]
    y=L[1]
    E = [liste[0] for liste in M] + [liste[-1] for liste in M]
    if y in E:
        for i, liste in enumerate(M):
            if liste[0] == y:
                j = 0
                while j < len(liste) and liste[j] != y:
                    j += 1
                if j == 0:
                    liste.insert(0, x)
                else:
                    liste.insert(j+1, x)
                return M
            elif liste[-1] == y:
                j = len(liste) - 1
                while j >= 0 and liste[j] != y:
                    j -= 1
                if j == len(liste) - 1:
                    liste.append(x)
                else:
                    liste.insert(j+1, x)
                return M
    else:
        M.append([x])
        return M
  #
  def ajouter_liste(self,L, M):
    M.append(L)
    return M
  #
  def fusion(self, L1, L2, j, k, M):
    M.remove(L1)
    M.remove(L2)
    if j == 0 and k == 0:
        L2 = L2[::-1]
        L2.extend(L1)
        M.append(L2)
        return M
    elif j == 0 and k != 0:
        L2.extend(L1)
        M.append(L2)
        return M
    elif j != 0 and k == 0:
        L1.extend(L2)
        M.append(L1)
        return M
    elif j != 0 and k != 0:
        L2 = L2[::-1]
        L1.extend(L2)
        M.append(L1)
        return M
  #
  def fusionner_listes(self, L, M):
    x=L[0]
    y=L[1]
    E = [lst[0] for lst in M] + [lst[-1] for lst in M]
    if x not in E and y not in E:
        return M
    elif x in E and y not in E:
        return M
    elif x not in E and y in E:
        return M
    elif x in E and y in E:
        i, j = next((i, j) for i, lst in enumerate(M) for j, elt in enumerate(lst) if elt == x)
        h, k = next((i, j) for i, lst in enumerate(M) for j, elt in enumerate(lst) if elt == y)
        if i == h:
            return M
        else:
            M=self.fusion(M[i], M[h], j, k,M)
            return M
  #
  def Construire_Tournées(self, I):
    M,V=[],[]
    M.append(I[0])
    V.append (I[0][0])
    V.append (I[0][1])
    I.pop(0)
    i=1
    for liste in I:
        if (liste[0] not in V and liste[-1] in V):
            M=self.ajouter_element1(liste, M)
            V.append(liste[0])
        elif (liste[0] in V and liste[-1] not in V):
            liste = liste[::-1]
            M=self.ajouter_element1(liste, M)
            V.append(liste[0])
        elif (liste[0] not in V and liste[-1] not in V):
            M.append(liste)
            V.append(liste[0])
            V.append(liste[1])
        elif (liste[0] in V and liste[-1] in V):
            M=self.fusionner_listes(liste, M)
        i+=1
    return M
  #
  def Cout (self,D,M):
    cout=0
    for i in range (len(M)-1):
        cout=cout+D[M[i]][M[i+1]]
    return cout
  #
  def deux_indices(self,T):
    n = len(T)
    L=[]
    if (len(T) < 2):
        raise ValueError("La tournée doit contenir au moins deux sommets.")
    ind = random.randint(0, n - 2)
    ind_x = ind
    ind_y = ind + 1
    L.append(ind_x)
    L.append(ind_y)
    return L
  #
  def compare (self,T):
    n = len(T)
    L2=[]
    if len(T) < 2:
        raise ValueError("La tournée doit contenir au moins deux sommets.")
    L1= self.deux_indices(T)
    ind = random.randint(0, n - 2)

    while L1[0] == T[ind] or L1[1] == T[ind+1] or L1[0] == T[ind+1] or L1[1] == T[ind]:
        ind = random.randint(0, n - 2)
    ind_a = ind
    ind_b = ind + 1
    L2.append(ind_a)
    L2.append(ind_b)
    return L1,L2
  #
  def two_opt(self, T):
    if len(T)>=4 :
        L1,L2=self.compare (T)
        x=T[L1[0]]
        T[L1[0]]=T[L2[0]]
        T[L2[0]]=x
        y=T[L1[1]]
        T[L1[1]]=T[L2[1]]
        T[L2[1]]=y
    return T
  #
  def Clark_Right(self,D,index):
    I=self.CW(D)
    M=self.Construire_Tournées(I)
    M[0].insert(0,self.Center[index])
    M=M[0]
    return M
  #
  def Generation_de_pop_CW(self,D,index):
    pop=[]
    T=self.Clark_Right(D,index)
    for i in range (20):
        T1=T.copy()
        M = self.two_opt(T1)
        pop.append(M)
    return pop
  #
  def Clark_Right1(self,D,V,oldD,c):
    pop=[]
    pop_v ={}
    for i in range (20):
        I=self.CW(D)
        M=self.Construire_Tournées(I)
        for l in M:
            M.insert(0,c)
        M=M[0]
        C1=self.Cout (oldD,M)
        MO=self.two_opt(M)
        C2=self.Cout (oldD,M)
        pop.append(MO)
        #
    pop_v[V]=pop
    self.pop.append(pop_v)
    #return self.pop
  #
  def Cout1 (self,D,pop):
    C=[]
    for i in pop:
        cout=0
        for j in range (len(i)-1):
            cout=cout+D[i[j]][i[j+1]]
        C.append(cout)
    return C
  #
  def Cout2 (self,D,M):
    cout=0
    for i in range (len(M)-1):
        cout=cout+D[M[i]][M[i+1]]
    return cout
  #
  def Deux_opt(self,D,T):
    opt=[]
    for i in range (len(T)):
        T1=T.copy()
        L = self.two_opt(T1)
        opt.append(L)
    c=self.Cout1 (D,opt)
    f_min=c[0]
    i=0
    pos_min=i
    while i<len(c) :
        if c[i] <= f_min :
            f_min=c[i]
            pos_min=i
        i=i+1
    T=opt[pos_min]
    return T
  #
  def MX1D (self,D,T,L):
    LN = [T[0]]
    h=T.index(T[0])
    k=L.index(T[0])
    c=L[h]
    L[h]=L[k]
    L[k]=c
    for i in range(len(T)-1):
        D_T = D[T[i]][T[i+1]]
        D_L = D[L[i]][L[i+1]]
        if  D_T <=  D_L:
            LN.append(T[i+1])
            h=T.index(T[i+1])
            k=L.index(T[i+1])
            c=L[h]
            L[h]=L[k]
            L[k]=c
        else:
            LN.append(L[i+1])
            h=L.index(L[i+1])
            k=T.index(L[i+1])
            c=T[h]
            T[h]=T[k]
            T[k]=c
    return LN
  #
  def Order_Crossover (self,D,T,L):
    ind1=random.randint(1, len(T)- 3)
    ind2 = random.randint(ind1 + 1, len(T)-2)
    LN1 = [-1] * len(T)
    LN2 = [-1] * len(T)
    LN1[ind1:ind2] = L[ind1:ind2]
    LN2[ind1:ind2] = T[ind1:ind2]
    index = ind2
    for x in T[ind2:] + T[:ind2]:
        if x not in LN1:
            LN1[index] = x
            index = (index + 1) % len(T)
    for i in range(len(LN1)):
        if LN1[i] == -1:
            for x in L:
                if x not in LN1:
                    LN1[i] = x
                    break
    for y in L[ind2:] + L[:ind2]:
        if y not in LN2:
            LN2[index] = y
            index = (index + 1) % len(L)
    for i in range(len(LN2)):
        if LN2[i] == -1:
            for y in T:
                if y not in LN2:
                    LN2[i] = y
                    break
    C1=self.Cout2 (D,LN1)
    C2=self.Cout2 (D,LN2)
    if C1<=C2 :
        LN=LN1
    else :
        LN=LN2
    return LN
  #
  def Cyclic_Crossover(self,D,T,L):
    LN=[]
    pos=[]
    F1 = [-1] * len(T)
    F2 = [-1] * len(T)
    l = random.randint(0, len(T) - 1)
    pos.append(l)
    F1[l]=T[l]
    F2[l]=L[l]
    for i in range(len(T) - 1):
        j=0
        while j< len(T):
            if T[j]==L[l]:
                l=j
                F1[l]=T[l]
                F2[l]=L[l]
                pos.append(l)
            j=j+1
    pos = list(set(pos))
    i=0
    while i<len(T):
        if i not in pos :
            F1[i]=L[i]
            F2[i]=T[i]
        i=i+1
    cout1=self.Cout2 (D,F1)
    cout2=self.Cout2 (D,F2)
    if cout1<=cout2:
        LN=F1
    else:
        LN=F2
    return LN
  #
  def Choix_prof(self,D,pop):
    fitness=self.Cout1 (D,pop)
    f_min=fitness[0]
    i=0
    pos_min=i
    while i<len(fitness) :
        if fitness[i] <= f_min :
            f_min=fitness[i]
            pos_min=i
        i=i+1
    T=pop[pos_min]
    return T
  #
  def Best_list(self,D,pop):
    fitness=self.Cout1 (D,pop)
    f_min=fitness[0]
    i=0
    pos_min=i
    while i<len(fitness) :
        if fitness[i] <= f_min :
            f_min=fitness[i]
            pos_min=i
        i=i+1
    T=pop[pos_min]
    return T
  #
  def TLBO(self,d,D,index):
    start_time = time.time()
    pop=self.Generation_de_pop_CW(d,index)
    for j in range (5):
        for i in range (0,len(pop)):
            E=pop[i]
            cE=self.Cout2 (D,E)
            T=self.Best_list(D,pop)
            t=pop.index(T)
            T1= T.copy()
            cT1=self.Cout2 (D,T1)
            E1=E.copy()
            LN1=self.MX1D (D,T1,E1)
            c1=self.Cout2 (D,LN1)
            T2= T.copy()
            cT2=self.Cout2 (D,T2)
            E2=E.copy()
            LN2=self.Order_Crossover (D,T2,E2)
            c2=self.Cout2 (D,LN2)
            T3= T.copy()
            cT3=self.Cout2 (D,T3)
            E3=E.copy()
            LN3=self.Cyclic_Crossover(D,T3,E3)
            c3=self.Cout2 (D,LN3)
            T7= T.copy()
            cT7=self.Cout2 (D,T7)
            if c1<=c2 and c1<=c3 and c1<=cE:
                E = LN1
            elif c2<=c1 and c2<=c3 and c2<=cE:
                E = LN2
            elif c3<=c1 and c3<=c2 and c3<=cE:
                E = LN3
            E7=E.copy()
            CE=self.Cout2 (D,E7)
            LN7=self.Deux_opt(D,E7)
            c7=self.Cout2 (D,LN7)
            if c7<CE :
                E = LN7
            ci=self.Cout2 (D,E)
            l = random.randint(0, len(pop) - 1)
            while l == i or l == t :
                l = random.randint(0, len(pop) - 1)
            L = pop[l]
            cL=self.Cout2 (D,L)
            E4= E.copy()
            L1=L.copy()
            LN4=self.MX1D (D,L1,E4)
            c4=self.Cout2 (D,LN4)
            E5= E.copy()
            L2=L.copy()
            LN5=self.Order_Crossover (D,L2,E5)
            c5=self.Cout2 (D,LN5)
            E6=E.copy()
            L3=L.copy()
            LN6=self.Cyclic_Crossover(D,L3,E6)
            c6=self.Cout2 (D,LN6)
            T8= T.copy()
            cT8=self.Cout2 (D,T8)
            if c4<=c5 and c4<=c6 and c4<=ci:
                E = LN4
            elif c5<=c4 and c5<=c6 and c5<=ci:
                E = LN5
            elif c6<=c4 and c6<=c5 and c6<=ci:
                E = LN6
            E8=E.copy()
            ce=self.Cout2 (D,E8)
            LN8=self.Deux_opt(D,E8)
            c8=self.Cout2 (D,LN8)
            if c8<ce :
                E = LN8
            pop[i]=E
        best=self.Best_list(D,pop)
        coutbest=self.Cout2 (D,best)
    end_time = time.time()
    execution_time = end_time - start_time
    self.pop_ameliori.append(best)
    #return best
  #
  def TLBO1(self,D,pop,V):
    #pop = self.pop
    d={}
    for j in range (5):
        for i in range (0,len(pop)):
            E=pop[i]
            cE=self.Cout2 (D,E)
            T=self.Choix_prof(D,pop)
            t=pop.index(T)
            T1= T.copy()
            cT1=self.Cout2 (D,T1)
            E1=E.copy()
            LN1=self.MX1D (D,T1,E1)
            c1=self.Cout2 (D,LN1)
            T2= T.copy()
            cT2=self.Cout2 (D,T2)
            E2=E.copy()
            LN2=self.Order_Crossover (D,T2,E2)
            c2=self.Cout2 (D,LN2)
            T3= T.copy()
            cT3=self.Cout2 (D,T3)
            E3=E.copy()
            LN3=self.Cyclic_Crossover(D,T3,E3)
            c3=self.Cout2 (D,LN3)
            T7= T.copy()
            cT7=self.Cout2 (D,T7)
            E7=E.copy()
            LN7=self.Deux_opt(D,E7)
            c7=self.Cout2 (D,LN7)
            if c1<=c2 and c1<=c3 and c1<=c7 and c1<=cE:
                E = LN1
            elif c2<=c1 and c2<=c3 and c2<=c7 and c2<=cE:
                E = LN2
            elif c3<=c1 and c3<=c2 and c3<=c7 and c3<=cE:
                E = LN3
            elif c7<=c1 and c7<=c2 and c7<=c3 and c7<=cE:
                E = LN7
            else:
                print('E else',E)
            ci=self.Cout2 (D,E)
            l = random.randint(0, len(pop) - 1)
            while l == i or l == t :
                l = random.randint(0, len(pop) - 1)
            L = pop[l]
            cL=self.Cout2 (D,L)
            E4= E.copy()
            L1=L.copy()
            LN4=self.MX1D (D,L1,E4)
            c4=self.Cout2 (D,LN4)
            E5= E.copy()
            L2=L.copy()
            LN5=self.Order_Crossover (D,L2,E5)
            c5=self.Cout2 (D,LN5)
            E6=E.copy()
            L3=L.copy()
            LN6=self.Cyclic_Crossover(D,L3,E6)
            c6=self.Cout2 (D,LN6)
            T8= T.copy()
            cT8=self.Cout2 (D,T8)
            E8=E.copy()
            LN8=self.Deux_opt(D,E8)
            c8=self.Cout2 (D,LN8)
            if c4<=c5 and c4<=c6 and c4<=c8 and c4<=ci:
                E = LN4
            elif c5<=c4 and c5<=c6 and c5<=c8 and c5<=ci:
                E = LN5
            elif c6<=c4 and c6<=c5 and c6<=c8 and c6<=ci:
                E = LN6
            elif c8<=c4 and c8<=c5 and c8<=c6 and c8<=ci:
                E = LN8
            else:
                print('E else',E)
            pop[i]=E
        coutpop=self.Cout1 (D,pop)
        #print('C',coutpop)
    d[V]={'pop':pop,'cout':coutpop}
    #self.cout = coutpop
    #self.pop_ameliori = pop
    self.pop_ameliori.append(pop)
    #return pop,coutpop
    return d
  #
  def Create_Matrix(self):
    D = self.D
    P = self.P
    for index,cluster in enumerate(self.Clustering):
      #
      vehic = {}
      matrix = []
      for clt in cluster:
        #
        indx = {}
        #
        indx[clt]=[D[clt][x]for x in cluster]
        #
        matrix.append(indx)
        #
        #
      vehic[index] = matrix
      self.vehicule_matrix.append(vehic)
      #
    return self.vehicule_matrix
  #
  def AffectCenter(self):
    #
    for index,cluster in zip(self.Center,self.Clustering):
      x = cluster[0]
      pos = cluster.index(index)
      cluster[0]=index
      cluster[pos] = x
  #
  def station(self):
    #
    p = [x[-1] for x in self.pop_ameliori]
    p_crd = [self.coordonne[x] for x in p]
    #
    data = pd.read_excel('../amiraTafsoutPickup/static/data/Stations.xlsx')
    #df = pd.DataFrame(data)
    #data = df.dropna()
    for s in list(zip(data['Latitude'],data['Longitude'],data['Stations '])):
      #
      dis = list(map(lambda x:float(str(geodesic((s[0],s[1]),x)).strip('km')),p_crd))
      dis_indx = list(zip(dis,p))
      client = sorted(dis_indx)[0]
      index = p.index(client[1])
      self.pop_ameliori[index].append(s[2])
  #
  def station1(self):
    #
    p = [x[-1] for x in self.pop_ameliori]
    p_crd = [self.coordonne[x] for x in p]
    #
    data = pd.read_excel('../amiraTafsoutPickup/static/data/Stations.xlsx')
    #df = pd.DataFrame(data)
    #data = df.dropna()
    #for s in list(zip(data['Latitude'],data['Longitude'],data['Stations '])):
    for index,c in enumerate(p_crd):
      #
      dis = list(map(lambda x:float(str(geodesic(c,x)).strip('km')),list(zip(data['Latitude'],data['Longitude']))))
      dis_indx = list(zip(dis,data['Stations ']))
      stat = sorted(dis_indx)[0]
      self.pop_ameliori[index].append(stat[1])

  #
  def tokanization(self):
    #
    #
    data = pd.read_excel(r'../amiraTafsoutPickup/static/data/clients statiques.xlsx')
    #
    crd = list(map(lambda x:x,list(zip(data['Latitude'],data['Longitude']))))
    #
    self.N = [x for x in range(len(data))]
    #
    self.coordonne = crd
  #
  def create_distance_matrix(self):
    matrix=[]
    for cor in self.coordonne:
      distance=list(map(lambda x:float(str(geodesic(cor,x)).strip('km')),self.coordonne))
      matrix.append(distance)
        #
    self.D = matrix
    #return matrix
  #
  def vector_init_distance(self):
    init_dis=list(zip(list(map(lambda x:float(str(geodesic(self.init,x)).strip('km')),self.coordonne)),self.clients))
    return init_dis
  #
  def insertClient(self,crd):
    #
    d=[0]
    #
    for index,x in enumerate(self.D):
      #
      x.append(float(str(geodesic(self.coordonne[index],crd)).strip('km')))
      d.append(float(str(geodesic(crd,self.coordonne[index])).strip('km')))
      #
    self.D.append(d)
    cnt = [ (self.D[-1][x],x) for x in self.Center]
    cnt = sorted(cnt)[0]
    self.Clustering[self.Center.index(cnt[1])].append(len(self.D)-1)
    self.coordonne.append(crd)
  #
  def dynamiClient(self):
    #
    data = pd.read_excel('../amiraTafsoutPickup/static/data/clients dynamiques.xlsx')
    df = pd.DataFrame(data)
    data = df.dropna()
    #crd = list(map(lambda x:self.insertClient(x),list(zip(data['Latitude'],data['Longitude']))))
    crd = list(map(self.insertClient,list(zip(data['Latitude'],data['Longitude']))))
    self.N.append(self.N[-1]+1)

  #

if __name__ == '__main__':
  #
  start_time = time.time()
  P=4
  #
  pick = pickup(P)
  #
  pick.tokanization()
  pick.create_distance_matrix()
  #
  #
  pick.Recouvrement()
  pick.AffectCenter()
  pick.Create_Matrix()
  #
  for index,m in enumerate(pick.vehicule_matrix):
    #
    matrix=list(m.values())[0]
    vehicule=list(m.keys())[0]
    #
    #d=[list(x.values())[0]for x in list(m.values())[0]]
    #
    pop = pick.TLBO(m,pick.D,index)
    #
    end_cluster = time.time()
    #print('cluster nb : ',index,'',end_cluster - start_time)

  #
  pick.station()
  #[print('clustering len',len(x)) for x in pick.Clustering]
  #[print('pop len',len(x)) for x in pick.pop_ameliori]
  [print('Station',x[-1]) for x in pick.pop_ameliori]
  print('Dynamic')
  #
  pick.dynamiClient()
  pick.pop_ameliori = []
  pick.vehicule_matrix = []
  #pick.Clustering = [x[2:]for x in pick.Clustering]
  #with
  #[print('clustering len',len(x)) for x in pick.Clustering]
  pick.Create_Matrix()
  for index,m in enumerate(pick.vehicule_matrix):
    #
    matrix=list(m.values())[0]
    vehicule=list(m.keys())[0]
    #
    #d=[list(x.values())[0]for x in list(m.values())[0]]
    #
    pick.TLBO(m,pick.D,index)
    #
    end_cluster = time.time()

  #
  pick.station()
  #[print('pop len',len(x)) for x in pick.pop_ameliori]
  [print('Station',x[-1]) for x in pick.pop_ameliori]